# -*- coding: utf-8 -*-
# PyCUDA による「包括（inclusive）スキャン」を用いた **逐次最大値（prefix-maximum）** の例である。
# InclusiveScanKernel に加算ではなく「max 演算（a>b ? a:b）」を与えることで、
# 先頭から各位置 i までの最大値 out[i] = max(x[0..i]) を並列に計算するである。

import numpy as np

# CUDA デバイス初期化は import の副作用で行われるである（コンテキスト生成）。
import pycuda.autoinit  # noqa: F401

import pycuda.gpuarray as gpuarray

# スキャン（prefix-sum/ここでは prefix-max）用のユーティリティを読み込むである。
from pycuda.scan import InclusiveScanKernel

# ------------------------------------------------------------
# 1) スキャン用カーネルの定義である。
#    第1引数: 要素型（np.int32）。GPU 側の演算型と一致させることが重要である。
#    第2引数: 結合演算を C 風の式で指定する。ここでは三項演算子で「a と b の大きい方」を返す。
#             これにより「逐次最大（prefix-maximum）の inclusive スキャン」が実現されるである。
#             ※ inclusive のため out[i] には x[i] 自身も比較対象として含まれる。
# ------------------------------------------------------------
scan_kernel = InclusiveScanKernel(np.int32, "a > b ? a : b")

# ------------------------------------------------------------
# 2) 入力データの用意である。
#    0..9 の等差配列を作り、乱択で並べ替える。最大値は 9 で不変であるため検算が容易である。
# ------------------------------------------------------------
x = np.arange(10, dtype=np.int32)
np.random.seed(123)      # 乱数シードを固定し再現性を確保するである。
np.random.shuffle(x)     # 配列順序をシャッフルするである。
print("original data: ", x)

# ------------------------------------------------------------
# 3) ホスト→デバイス転送である。GPUArray はデバイスメモリ上の配列を表現するラッパである。
# ------------------------------------------------------------
x_gpu = gpuarray.to_gpu(x)

# ------------------------------------------------------------
# 4) InclusiveScanKernel の **注意点**：
#    - 渡した配列を **破壊的（in-place）に上書き** して結果を書き戻す設計である。
#    - 原配列を保持したい場合は .copy() で別バッファを用意するである。
# ------------------------------------------------------------
x_gpu2 = x_gpu.copy()
scan_kernel(x_gpu2)   # 逐次最大（prefix-max）の inclusive スキャンを実行するである。

# ------------------------------------------------------------
# 5) デバイス→ホスト転送で結果を取得し、検算するである。
#    - 出力配列 result は各位置までの最大値列になる（例: [a0, max(a0,a1), max(a0..a2), ...]）。
#    - 最終要素は配列全体の最大値に一致する（np.max と等しい）である。
# ------------------------------------------------------------
print("result: ", x_gpu2.get())
print("max :", np.max(x))  # 逐次最大列の末尾と一致するはずである。

# 補足（である）:
# - 最大演算は可換・結合的であるため、スキャンの結合演算として適している。
# - 型（np.int32）はカーネル生成時の指定と一致させること。型不一致は未定義動作や桁あふれの原因となる。
# - Exclusive（排他的）スキャンが必要な場合は、結果を一つ右へシフトし先頭を最小値（例: INT32_MIN）で埋める等の処理で得られる。