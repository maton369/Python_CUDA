# -*- coding: utf-8 -*-
"""
PyCUDA による包括（inclusive）スキャンの最小例である。
inclusive scan（累積和）は配列 a について
  out[i] = a[0] + a[1] + ... + a[i]
を各 i で計算する演算であり、並列 prefix-sum の代表例である。
"""

import numpy as np

# CUDA デバイスの初期化を import の副作用で行うである。
# これによりデフォルトコンテキストが生成され、以降の PyCUDA API を即座に利用できる。
import pycuda.autoinit  # noqa: F401

import pycuda.gpuarray as gpuarray

# スキャン（prefix-sum）用のユーティリティである InclusiveScanKernel を読み込むである。
# Inclusive（包括）なので、各位置 i の結果に a[i] 自身も含まれる点に注意するである。
from pycuda.scan import InclusiveScanKernel

# ------------------------------------------------------------
# 1) スキャン用カーネルの定義である。
#    第1引数: 要素型（ここでは 32-bit 整数 np.int32）
#    第2引数: 結合演算（可換・結合的であることが望ましい）。"a+b" を与えて加算スキャンにするである。
# ------------------------------------------------------------
scan_kernel = InclusiveScanKernel(np.int32, "a+b")

# ------------------------------------------------------------
# 2) 入力データの用意（ホスト側 NumPy 配列）である。
# ------------------------------------------------------------
x = np.arange(10, dtype=np.int32)  # [0,1,2,...,9]

# 参照解（CPU 側）の累積和を表示しておくである（inclusive な np.cumsum と一致するはずである）。
print("answer :", np.cumsum(x))

# ------------------------------------------------------------
# 3) ホスト→デバイス転送である。GPUArray はデバイス上の一次元配列を表現するである。
# ------------------------------------------------------------
x_gpu = gpuarray.to_gpu(x)

# ------------------------------------------------------------
# 4) InclusiveScanKernel の注意点:
#    * 与えた配列を **破壊的（in-place）に上書き** して結果を書き戻す設計である。
#    * 原データも保持したい場合は、必ずコピーを作ってから適用するである。
# ------------------------------------------------------------
x_gpu2 = x_gpu.copy()  # 破壊を避けるための防御的コピーである。

# ------------------------------------------------------------
# 5) スキャンの実行である。引数に GPUArray を渡すだけで inclusive prefix-sum が適用されるである。
#    内部ではブロック内スキャン → ブロック間のオフセット伝播という二段階処理が行われる実装が一般的である。
# ------------------------------------------------------------
scan_kernel(x_gpu2)

# ------------------------------------------------------------
# 6) デバイス→ホスト転送で結果を取得し、表示するである。
# ------------------------------------------------------------
print("scan result: ", x_gpu2.get())

# 期待される出力（例）である：
# answer :      [ 0  1  3  6 10 15 21 28 36 45]
# scan result : [ 0  1  3  6 10 15 21 28 36 45]
#
# 備考である：
# - Exclusive（排他的）スキャンが必要であれば、Inclusive の結果を一要素右にシフトし先頭を単位元（0）で埋める等の後処理で得られる。
# - 型はカーネル定義時のもの（np.int32）と一致させる必要がある。型不一致は実行時エラーや桁あふれの原因となるである。